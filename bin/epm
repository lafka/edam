#!/usr/bin/env escript

%% -*- mode: erlang;
%% ex: ft=erlang et

-define(lib(Name, Vsn), "lib/" ++ Name ++ $- ++ Vsn).

-include("../src/epm.hrl").

main([]) ->
    target(["help"], []);
main(Args) ->
    try
        Dir = get_codepath(escript:script_name()),
        true = code:add_path(filename:join([Dir, "ebin"])),
        {Cmd, Opts} = lists:partition(fun(
              [$-|_]) -> false; (_) -> true end
            , Args),
        epm:init([{basedir, Dir}]),
        case parse_args(Opts, ok) of
            ok ->
                epm_utils:debug("args: ~p", [Cmd]),
                target(Cmd, Opts);
            error ->
                ok
        end
    catch C:R ->
        epm_utils:err("aaaah fuuuuuck something broke :(~n~n"
            "error: ~p~n"
            "reason: ~p~n"
            "trace: ~p~n", [C, R, erlang:get_stacktrace()])
    end.

parse_args([], Acc) -> Acc;
parse_args(_, error) -> error;
parse_args(["-v", Verbosity | T], _) ->
    epm:set(verbosity, Verbosity),
    parse_args(T, ok);
parse_args(["-d" | T], _) ->
    epm:set(dryrun, true),
    parse_args(T, ok);
parse_args([Arg | T], _) ->
    io:format("parse: unknown argument '~s'~n", [Arg]),
    parse_args(T, error).

get_codepath([$/|_] = File) ->
    filename:dirname(filename:dirname(File));
get_codepath(File) ->
    {ok, Base} = file:get_cwd(),
    filename:dirname(filename:dirname(filename:join(Base, File))).

usage() ->
    io:format("usage: epm {build|deps|key}~n").

target(["help" | _], _Opts) ->
    io:format("epm {build|deps|sign|key}~n"
        "~n"
        "  Commands:~n"
        "==========================================================~n"
        "~n"
        "= build~n"
        "  Build something, you should use make/rebar/sinan/erlc/emake.~n"
        "~n"
        "= deps {search|fetch|update|check|print|help}~n"
        "  Find, check, manage and display dependencies.~n"
        "~n"
        "= key {import|revoke|generate|list|help}~n"
        "  Key management for remote repositories and signing.~n"
        "~n"
        "= sign~n"
        "  Sign your source code for releases.~n"
        "~n"
        " OPTIONS:~n"
        "==========================================================~n"
        "~n"
        " -v <lvl>       Level of output to display~n"
        " -d, --dry-run  Dry run, don't actually do anything~n"
        );

target(["build"], _Opts) ->
    epm_utils:info("building~n");

target(["deps"], Opts) ->
    target(["deps", "sync"], Opts);

target(["deps", "help" | _], _Opts) ->
    io:format("epm deps {search|fetch|update|check|print|help}~n"
        "~n"
        "= search <package>~n"
        "  Search all repositories for a package package.~n"
        "~n"
        "= fetch [<package>,..]~n"
        "  Fetch one or more packages to local store for later use.~n"
        "~n"
        "= sync [package]~n"
        "  Update all repositories, optionaly only update [package]~n"
        "  if specified.~n"
        "~n"
        "= check [package]~n"
        "  Check if repositores are up to date, fetches the remote~n"
        "  status of all packages. Optionally specify [package] to~n"
        "  only check single dependency.~n"
        "~n"
        "= print [package]~n"
        "  Print out the current status for all your dependencies.~n"
        "  If package is given the configuration for that package~n"
        "  will be used."
        "~n"
       );

target(["deps", "search"], _Opts) ->
    io:format("deps search: you must specify search phrase~n");

target(["deps", "search", _Phrase], _Opts) ->
    epm_utils:err("deps search: not implemented");

target(["deps", "fetch"], _Opts) ->
    io:format("deps fetch: you must specify a package~n");

target(["deps", "fetch", _Deps], _Opts) ->
    epm_utils:err("deps fetch: not implemented");

target(["deps", "sync"], Opts) ->
    target(["deps", "sync", "."], Opts);

target(["deps", "sync", Path], _Opts) ->
    Cfg = epm_config:parse(Path),
    lists:foreach(fun(#dep{} = Dep) ->
        Dep2 = epm_deps:match_repos(Dep, Cfg),
        epm_deps:update(Dep2)
       end, Cfg#cfg.deps),
    ok;

target(["deps", "check"], Opts) ->
    target(["deps", "check", "."], Opts);

target(["deps", "check", Path], _Opts) ->
    Cfg = epm_config:parse(Path),
    lists:foreach(
        fun(#dep{repo = []} = Dep) ->
            io:format("= ~s -> missing repository~n", [Dep#dep.name]);
        (#dep{repo = [{Repo,_,_}|_]} = Dep) ->
            Dep2 = epm_deps:match_repos(Dep, Cfg),
            case epm_deps:has_update(Dep2) of
                true ->
                    io:format("= ~s:~s -> has remote updates~n"
                        , [Repo, Dep2#dep.name]);
                missing ->
                    io:format("= ~s:~s -> not checked out~n"
                        , [Repo, Dep2#dep.name]);
                unknown ->
                    io:format("= ~s:~s=~s -> missing local copy~n"
                        , [Repo, Dep2#dep.name, Dep2#dep.version]);
                false ->
                    ok
            end
       end, Cfg#cfg.deps),
    ok;

target(["deps", "print"], Opts) ->
    target(["deps", "print", "."], Opts);

target(["deps", "print", Path], _Opts) ->
    epm:set(autofetch, false),
    Cfg = epm_config:parse(Path),
    epm_config:print(Cfg);

target(["sign"], _Opts) ->
    epm_utils:err("sign: not implemented");

target(["key"], Opts) ->
    target(["key", "help"], Opts);

target(["key", "help"|_], _Opts) ->
    io:format("epm key {import|revoke|generate|list|help}~n"
        "~n"
        "= import~n"
        "  Add a key to your keychain.~n"
        "~n"
        "= revoke~n"
        "  Remove a trusted key from your keychain.~n"
        "~n"
        "= generate~n"
        "  Generate a new key used for signing.~n"
        "~n"
        "= list~n"
        "  List all trusted keys.~n"
        "~n");

target(["key", "import"], _Opts) ->
    epm_utils:err("key import: not implemented");

target(["key", "revoke"], _Opts) ->
    epm_utils:err("key revoke: not implemented");

target(["key", "generate"], _Opts) ->
    epm_utils:err("key generate: not implemented");

target(["key", "list"], _Opts) ->
    epm_utils:err("key generate: not implemented");

target(Args, _Opts) ->
    io:format("unknown command ~p~n", [Args]),
    usage().
